from dataclasses import dataclass, field
from typing import Any, Callable, Optional, Tuple, List, TypeVar, Generic
from enum import Enum, auto

T = TypeVar('T')  # Generic type for parser results
U = TypeVar('U')

# pyparsec/Parsec.py (or a new types.py)

from dataclasses import dataclass
from typing import Generic, Tuple, Optional, Any




@dataclass
class SourcePos:
    """Represents the current position in the input stream."""
    line: int = 1
    column: int = 1
    name: str = ""

# pyparsec/Parsec.py
    def update(self, token: str) -> 'SourcePos':
        """
        Update position based on a token (e.g., character).
        Handles newlines and tabs correctly.
        """
        if token == '\n':
            return SourcePos(self.line + 1, 1, self.name)
        elif token == '\t':
            # Advance to the next tab stop (assuming tab stops are every 8 columns)
            # Correct logic: new_col = old_col + tab_width - (old_col - 1) % tab_width
            tab_width = 8
            new_column = self.column + tab_width - ((self.column - 1) % tab_width)
            return SourcePos(self.line, new_column, self.name)
        else:
            # For any other character, increment the column by 1
            return SourcePos(self.line, self.column + 1, self.name)
    def __str__(self) -> str:
        return f"{self.name} line {self.line}, column {self.column}"

    def __gt__(self, other: 'SourcePos') -> bool:
        if self.line != other.line:
            return self.line > other.line
        return self.column > other.column

    def __lt__(self, other: 'SourcePos') -> bool:
        if self.line != other.line:
            return self.line < other.line
        return self.column < other.column

    def __eq__(self, other: 'SourcePos') -> bool:
        return self.line == other.line and self.column == other.column

@dataclass
class State(Generic[T]):
    """Parser state: input stream, position, and user state."""
    input: str  # Simplified to string input; could be generalized
    pos: SourcePos
    user: Any


class MessageType(Enum):
    SYS_UNEXPECT = auto()  # System-generated unexpected token (e.g., from satisfy)
    UNEXPECT = auto()      # User-generated unexpected token (e.g., from unexpected())
    EXPECT = auto()        # Expected item (e.g., from label() or <?>)
    MESSAGE = auto()       # Raw message (e.g., from fail())

@dataclass
class Message:
    type: MessageType
    text: str

    # For sorting and merging (Parsec orders them)
    def __lt__(self, other: 'Message') -> bool:
        if self.type.value != other.type.value:
            return self.type.value < other.type.value
        return self.text < other.text # Arbitrary but consistent tie-break

    # __eq__ and __hash__ will be auto-generated by dataclass if not provided,
    # but good to be explicit if we add custom __lt__
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Message):
            return NotImplemented
        return self.type == other.type and self.text == other.text

    def __hash__(self) -> int:
        return hash((self.type, self.text))

@dataclass
class ParseError:
    """Represents a parsing error with a position and list of messages."""
    pos: SourcePos
    messages: List[Message] = field(default_factory=list) # Now a list of Message objects

    def __str__(self) -> str:
        if not self.messages:
            return f"Unknown parse error at {self.pos}"
        
        # Simplified formatting for now, can be made richer like Haskell's showErrorMessages
        # Group messages by type for better output (optional, but good for complex errors)
        expects = sorted(list(set(m.text for m in self.messages if m.type == MessageType.EXPECT)))
        unexpects = sorted(list(set(m.text for m in self.messages if m.type == MessageType.UNEXPECT or m.type == MessageType.SYS_UNEXPECT)))
        others = sorted(list(set(m.text for m in self.messages if m.type == MessageType.MESSAGE)))

        msg_parts = []
        if unexpects:
            if len(unexpects) == 1 and unexpects[0] == "": # For SysUnExpect "" (EOF)
                 msg_parts.append("unexpected end of input")
            else:
                msg_parts.append(f"unexpected {', or '.join(unexpects)}")
        if expects:
            msg_parts.append(f"expecting {', or '.join(expects)}")
        if others:
            msg_parts.extend(others)
        
        return f"Parse error at {self.pos}: {'; '.join(msg_parts)}"

    def is_unknown(self) -> bool:
        return not self.messages

    def add_message(self, msg: Message) -> 'ParseError':
        # Avoid duplicate messages of the same type and text
        if msg not in self.messages:
            return ParseError(self.pos, self.messages + [msg])
        return self
    
    def set_messages(self, msgs: List[Message]) -> 'ParseError':
        return ParseError(self.pos, sorted(list(set(msgs)))) # Keep them sorted and unique

    @staticmethod
    def new_unknown(pos: SourcePos) -> 'ParseError':
        return ParseError(pos, [])

    @staticmethod
    def new_message(pos: SourcePos, msg_type: MessageType, text: str) -> 'ParseError':
        return ParseError(pos, [Message(msg_type, text)])

    # Key function for merging errors
    @staticmethod
    def merge(err1: 'ParseError', err2: 'ParseError') -> 'ParseError':
        # If one is unknown, prefer the other
        if err1.is_unknown(): return err2
        if err2.is_unknown(): return err1

        # Compare positions
        if err1.pos > err2.pos: return err1
        if err2.pos > err1.pos: return err2
        
        # Positions are the same, merge messages
        # Using set to keep messages unique, then converting back to list and sorting
        # Sorting helps in consistent error messages and follows Parsec's behavior.
        combined_messages = sorted(list(set(err1.messages + err2.messages)))
        return ParseError(err1.pos, combined_messages)

@dataclass
class Reply(Generic[T]):
    value: Optional[T]
    state: State # The state *after* this part of the parse attempt
    error: Optional[ParseError]
    # is_ok: bool # Could be implicit: value is not None and (error is None or error.is_unknown())

# ParseResult of a parser function, now explicitly stating consumption
@dataclass
class ParseResult(Generic[T]):
    reply: Reply[T]
    consumed: bool # True if input was consumed, False otherwise

    @property
    def value(self) -> Optional[T]:
        return self.reply.value

    @property
    def state(self) -> State:
        return self.reply.state

    @property
    def error(self) -> Optional[ParseError]:
        return self.reply.error

    @staticmethod
    def ok_consumed(value: T, new_state: State, err: Optional[ParseError]) -> 'ParseResult[T]':
        return ParseResult(Reply(value, new_state, err), True)

    @staticmethod
    def ok_empty(value: T, original_state: State, err: Optional[ParseError]) -> 'ParseResult[T]':
        # For ok_empty, the state in Reply should be the original_state
        # if we strictly follow Parsec, though often new_state is passed if value depends on it.
        # Let's keep it simple: state reflects the state *after* this logical step.
        return ParseResult(Reply(value, original_state, err), False)

    @staticmethod
    def error_consumed(new_state: State, err: ParseError) -> 'ParseResult[Any]': # Use Any for error results
        return ParseResult(Reply(None, new_state, err), True)

    @staticmethod
    def error_empty(original_state: State, err: ParseError) -> 'ParseResult[Any]':
        return ParseResult(Reply(None, original_state, err), False)

class Parsec(Generic[T]):
    """A parser combinator that processes input and returns a result."""
    def __init__(self, parse_fn: Callable[[State], ParseResult[T]]): # Input function produces ParseResult[T]
        self.parse_fn = parse_fn

    def __call__(self, state: State) -> ParseResult[T]: # Parsec[T] produces ParseResult[T]
        return self.parse_fn(state)

    # Monadic bind (>>=)
    def bind(self, f: Callable[[T], 'Parsec[U]']) -> 'Parsec[U]':
        def parse(state: State) -> ParseResult[U]: # Changed
            res_self = self(state) # res_self is ParseResult[T]

            # If self errored with a "known" error, propagate it with its consumption status
            if res_self.error and not res_self.error.is_unknown():
                return ParseResult(res_self.reply, res_self.consumed)

            # If self produced no value (e.g. error was None or unknown, but value was None)
            # This indicates an issue; treat as an empty error for safety.
            if res_self.value is None:
                return ParseResult.error_empty(
                    res_self.state, # state after self's attempt
                    res_self.error or ParseError.new_unknown(res_self.state.pos)
                )

            # Self succeeded (res_self.value is not None)
            next_parser = f(res_self.value)
            # Run next_parser on the state *after* self has processed
            res_next = next_parser(res_self.state) # res_next is ParseResult[U]

            # Determine overall consumption: if self OR next consumed, it's consumed.
            consumed_overall = res_self.consumed or res_next.consumed

            # If next_parser errored with a "known" error
            if res_next.error and not res_next.error.is_unknown():
                # Merge next_parser's error with self's error (which is likely unknown here)
                # The state for the error reply is from res_next
                # The consumption status is consumed_overall
                final_err = ParseError.merge(
                    res_self.error or ParseError.new_unknown(res_self.state.pos), # error from self (likely unknown)
                    res_next.error
                )
                return ParseResult(Reply(None, res_next.state, final_err), consumed_overall)

            # Both self and next_parser succeeded
            # The value is from res_next
            # The state is from res_next
            # Errors are merged (both likely unknown, resulting in an unknown error for the combined success)
            # Consumption is consumed_overall
            final_err_on_success = ParseError.merge(
                res_self.error or ParseError.new_unknown(res_self.state.pos),
                res_next.error or ParseError.new_unknown(res_next.state.pos)
            )
            return ParseResult(Reply(res_next.value, res_next.state, final_err_on_success), consumed_overall)
        return Parsec(parse)

    # Alternative (<|>)
    def __or__(self, other: 'Parsec[T]') -> 'Parsec[T]':
        def parse(state: State) -> ParseResult[T]: # Changed
            res1 = self(state) # res1 is ParseResult[T]

            # If res1 succeeded (value is present and error is unknown/None)
            # OR if res1 failed *after consuming input*, then return res1's result.
            if (res1.value is not None and (res1.error is None or res1.error.is_unknown())) \
               or res1.consumed:
                return res1

            # At this point, res1 failed *without consuming input* (res1.consumed is False)
            # So, try the 'other' parser, starting from the original 'state'.
            res2 = other(state) # res2 is ParseResult[T]

            # If res2 also failed without consuming input (i.e., it's an empty error),
            # then merge the errors from res1 and res2.
            if res1.error and res2.error and not res2.consumed : # Both are empty errors
                merged_err = ParseError.merge(res1.error, res2.error)
                # The reply state is the original state, and it's an empty failure.
                return ParseResult.error_empty(state, merged_err)
            
            # Otherwise (res2 succeeded, or res2 failed but consumed input),
            # the result of res2 takes precedence.
            return res2
        return Parsec(parse)

# --- Applicative Functor style operators ---
    # (&) Sequence, keeping both results
    def __and__(self, other: 'Parsec[U]') -> 'Parsec[Tuple[T, U]]':
        return self.bind(lambda val_t: other.bind(lambda val_u: _pure((val_t, val_u))))

    # (*>) Sequence, keeping right result
    def __gt__(self, other: 'Parsec[U]') -> 'Parsec[U]':
        return self.bind(lambda _: other)

    # (<*) Sequence, keeping left result
    def __lt__(self, other: 'Parsec[U]') -> 'Parsec[T]':
        return self.bind(lambda val_t: other.bind(lambda _: _pure(val_t)))
    
    # Monadic bind also available as >>
    def __rshift__(self, f: Callable[[T], 'Parsec[U]']) -> 'Parsec[U]':
        return self.bind(f)

    def label(self, msg: str) -> 'Parsec[T]':
        def parse(state: State) -> ParseResult[T]: # Changed
            res = self(state) # res is ParseResult[T]

            # Only modify error if self failed *without consuming input*.
            if res.error and not res.consumed:
                # Create a new error by replacing/adding EXPECT messages.
                # Keep other message types from the original error.
                current_messages = res.error.messages if res.error else []
                new_messages = [m for m in current_messages if m.type != MessageType.EXPECT]
                new_messages.append(Message(MessageType.EXPECT, msg))
                
                # Error is at the original state's position, and it's an empty error.
                return ParseResult.error_empty(state, ParseError(state.pos, sorted(list(set(new_messages)))))
            
            # Otherwise (success, or consumed error), return the original result.
            return res
        return Parsec(parse)

def _pure(value: T) -> Parsec[T]:
    """Return a parser that succeeds with a value without consuming input."""
    def parse(state: State) -> ParseResult[T]:
        return ParseResult.ok_empty(value, state) # Default err is unknown
    return Parsec(parse)
