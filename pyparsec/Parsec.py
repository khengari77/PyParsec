from dataclasses import dataclass, field
from typing import Any, Callable, Optional, Tuple, List, TypeVar, Generic
from enum import Enum, auto

T = TypeVar('T')  # Generic type for parser results
U = TypeVar('U')

@dataclass
class SourcePos:
    """Represents the current position in the input stream."""
    line: int = 1
    column: int = 1
    name: str = ""

# pyparsec/Parsec.py
    def update(self, token: str) -> 'SourcePos':
        """
        Update position based on a token (e.g., character).
        Handles newlines and tabs correctly.
        """
        if token == '\n':
            return SourcePos(self.line + 1, 1, self.name)
        elif token == '\t':
            # Advance to the next tab stop (assuming tab stops are every 8 columns)
            # Correct logic: new_col = old_col + tab_width - (old_col - 1) % tab_width
            tab_width = 8
            new_column = self.column + tab_width - ((self.column - 1) % tab_width)
            return SourcePos(self.line, new_column, self.name)
        else:
            # For any other character, increment the column by 1
            return SourcePos(self.line, self.column + 1, self.name)
    def __str__(self) -> str:
        return f"{self.name} line {self.line}, column {self.column}"

    def __gt__(self, other: 'SourcePos') -> bool:
        if self.line != other.line:
            return self.line > other.line
        return self.column > other.column

    def __lt__(self, other: 'SourcePos') -> bool:
        if self.line != other.line:
            return self.line < other.line
        return self.column < other.column

    def __eq__(self, other: 'SourcePos') -> bool:
        return self.line == other.line and self.column == other.column

@dataclass
class State(Generic[T]):
    """Parser state: input stream, position, and user state."""
    input: str  # Simplified to string input; could be generalized
    pos: SourcePos
    user: Any


class MessageType(Enum):
    SYS_UNEXPECT = auto()  # System-generated unexpected token (e.g., from satisfy)
    UNEXPECT = auto()      # User-generated unexpected token (e.g., from unexpected())
    EXPECT = auto()        # Expected item (e.g., from label() or <?>)
    MESSAGE = auto()       # Raw message (e.g., from fail())

@dataclass
class Message:
    type: MessageType
    text: str

    # For sorting and merging (Parsec orders them)
    def __lt__(self, other: 'Message') -> bool:
        if self.type.value != other.type.value:
            return self.type.value < other.type.value
        return self.text < other.text # Arbitrary but consistent tie-break

    # __eq__ and __hash__ will be auto-generated by dataclass if not provided,
    # but good to be explicit if we add custom __lt__
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Message):
            return NotImplemented
        return self.type == other.type and self.text == other.text

    def __hash__(self) -> int:
        return hash((self.type, self.text))

@dataclass
class ParseError:
    """Represents a parsing error with a position and list of messages."""
    pos: SourcePos
    messages: List[Message] = field(default_factory=list) # Now a list of Message objects

    def __str__(self) -> str:
        if not self.messages:
            return f"Unknown parse error at {self.pos}"
        
        # Simplified formatting for now, can be made richer like Haskell's showErrorMessages
        # Group messages by type for better output (optional, but good for complex errors)
        expects = sorted(list(set(m.text for m in self.messages if m.type == MessageType.EXPECT)))
        unexpects = sorted(list(set(m.text for m in self.messages if m.type == MessageType.UNEXPECT or m.type == MessageType.SYS_UNEXPECT)))
        others = sorted(list(set(m.text for m in self.messages if m.type == MessageType.MESSAGE)))

        msg_parts = []
        if unexpects:
            if len(unexpects) == 1 and unexpects[0] == "": # For SysUnExpect "" (EOF)
                 msg_parts.append("unexpected end of input")
            else:
                msg_parts.append(f"unexpected {', or '.join(unexpects)}")
        if expects:
            msg_parts.append(f"expecting {', or '.join(expects)}")
        if others:
            msg_parts.extend(others)
        
        return f"Parse error at {self.pos}: {'; '.join(msg_parts)}"

    def is_unknown(self) -> bool:
        return not self.messages

    def add_message(self, msg: Message) -> 'ParseError':
        # Avoid duplicate messages of the same type and text
        if msg not in self.messages:
            return ParseError(self.pos, self.messages + [msg])
        return self
    
    def set_messages(self, msgs: List[Message]) -> 'ParseError':
        return ParseError(self.pos, sorted(list(set(msgs)))) # Keep them sorted and unique

    @staticmethod
    def new_unknown(pos: SourcePos) -> 'ParseError':
        return ParseError(pos, [])

    @staticmethod
    def new_message(pos: SourcePos, msg_type: MessageType, text: str) -> 'ParseError':
        return ParseError(pos, [Message(msg_type, text)])

    # Key function for merging errors
    @staticmethod
    def merge(err1: 'ParseError', err2: 'ParseError') -> 'ParseError':
        # If one is unknown, prefer the other
        if err1.is_unknown(): return err2
        if err2.is_unknown(): return err1

        # Compare positions
        if err1.pos > err2.pos: return err1
        if err2.pos > err1.pos: return err2
        
        # Positions are the same, merge messages
        # Using set to keep messages unique, then converting back to list and sorting
        # Sorting helps in consistent error messages and follows Parsec's behavior.
        combined_messages = sorted(list(set(err1.messages + err2.messages)))
        return ParseError(err1.pos, combined_messages)

# Result type remains the same conceptually, but ParseError is now richer
Result = Tuple[Optional[T], State, Optional[ParseError]]

class Parsec(Generic[T]):
    """A parser combinator that processes input and returns a result."""
    def __init__(self, parse_fn: Callable[[State], Result[T]]): # Input function produces Result[T]
        self.parse_fn = parse_fn

    def __call__(self, state: State) -> Result[T]: # Parsec[T] produces Result[T]
        return self.parse_fn(state)

    # Monadic bind (>>=)
    def bind(self, f: Callable[[T], 'Parsec[U]']) -> 'Parsec[U]':
        def parse(state: State) -> Result[U]:
            value, new_state, err = self(state)
            if err and err.messages: # Check if error is not "unknown"
                return None, new_state, err
            if value is None and err is None: # Should not happen if err logic is right
                return None, new_state, ParseError.new_unknown(new_state.pos)
            if value is None: # implies err is not None and has messages
                 return None, new_state, err


            # First parser succeeded (err is None or unknown)
            # If err was unknown, we effectively discard it and let next_parser define errors.
            # If err had messages (e.g. from a try_parse that failed but was caught),
            # this logic is a bit complex. For now, assume if value is present, err is ignorable or unknown.
            
            next_parser: 'Parsec[U]' = f(value) # value cannot be None here if no error
            
            # Run the next parser
            val_u, state_u, err_u = next_parser(new_state)

            # Merge errors if the first parser had a "known" error that was propagated
            # This part needs careful thought. Parsec's internal Consumed/Empty helps.
            # For now, let's assume if 'self' succeeded, 'err' is unknown.
            # If next_parser fails, its error (err_u) is the result.
            # If err was significant (not unknown) and next_parser also has err_u, they should merge.
            
            # Simplified merge logic: if self had an error, and next_parser also errors, merge.
            # This path is typically for when 'self' succeeded (value is not None).
            # If 'self' produced 'value' but also 'err' (e.g. from a consumed 'try_parse' failure),
            # and then 'f(value)' parser also fails, errors should be merged.
            # This is a subtle point. For now, let's assume if 'self' provides a 'value', its 'err' is 'unknown'.
            if err and not err.is_unknown() and err_u and not err_u.is_unknown():
                 return val_u, state_u, ParseError.merge(err, err_u)
            
            return val_u, state_u, err_u # Or just err_u if err from self is always unknown on success
        return Parsec(parse)

    # Alternative (<|>)
    def __or__(self, other: 'Parsec[T]') -> 'Parsec[T]':
        def parse(state: State) -> Result[T]:
            val1, state1, err1 = self(state)
            if val1 is not None and (err1 is None or err1.is_unknown()): # Success
                return val1, state1, err1 # err1 is likely unknown here

            # self failed
            # Only try other if no input was consumed by self
            if state.input == state1.input and state.pos == state1.pos: # More robust pos check
                val2, state2, err2 = other(state)
                if err1 and not err1.is_unknown() and err2 and not err2.is_unknown():
                    # Both failed without consuming, merge errors
                    return val2, state2, ParseError.merge(err1, err2)
                return val2, state2, err2 # Return other's result/error
            
            return val1, state1, err1 # self failed and consumed input
        return Parsec(parse)

    # Sequence (&)
    # self: Parsec[T], other: Parsec[U] -> result: Parsec[Tuple[T, U]]
    def __and__(self, other: 'Parsec[U]') -> 'Parsec[Tuple[T, U]]': # Now returns a Parsec of a Tuple
        def combined(state: State) -> Result[Tuple[T, U]]:
            value1, state1, err1 = self(state) # self is Parsec[T]
            if err1:
                return None, state1, err1

            value2, state2, err2 = other(state1) # other is Parsec[U]
            if err2:
                return None, state2, err2

            return (value1, value2), state2, ParseError.new_unknown(state2.pos) # Result is Tuple[T, U]
        return Parsec(combined)

    # Sequence (*>)
    # self: Parsec[T], other: Parsec[U] -> result: Parsec[U]
    def __gt__(self, other: 'Parsec[U]') -> 'Parsec[U]':
        def combined(state: State) -> Result[U]:
            _, state1, err1 = self(state) # self is Parsec[T], its value is discarded
            if err1:
                return None, state1, err1

            value2, state2, err2 = other(state1) # other is Parsec[U]
            if err2:
                return None, state2, err2

            return value2, state2, ParseError.new_unknown(state2.pos)
        return Parsec(combined)

    # Sequence (<*)
    # self: Parsec[T], other: Parsec[U] -> result: Parsec[T]
    def __lt__(self, other: 'Parsec[U]') -> 'Parsec[T]':
        def combined(state: State) -> Result[T]:
            value1, state1, err1 = self(state) # self is Parsec[T]
            if err1:
                return None, state1, err1

            _, state2, err2 = other(state1) # other is Parsec[U], its value is discarded
            if err2:
                return None, state2, err2
            
            return value1, state2, ParseError.new_unknown(state2.pos)
        return Parsec(combined)


    # Monadic bind also available as >>
    def __rshift__(self, f: Callable[[T], 'Parsec[U]']) -> 'Parsec[U]': # Changed other to f for clarity
        return self.bind(f)
    

    # Label (<?>)
    def label(self, msg: str) -> 'Parsec[T]':
        def parse(state: State) -> Result[T]:
            value, new_state, err = self(state)
            # Only modify error if self failed without consuming
            if err and state.input == new_state.input and state.pos == new_state.pos:
                # Replace 'EXPECT' messages, or add if none. Don't clobber UNEXPECT.
                new_messages = [m for m in err.messages if m.type != MessageType.EXPECT]
                new_messages.append(Message(MessageType.EXPECT, msg))
                return None, new_state, ParseError(state.pos, sorted(list(set(new_messages))))
            return value, new_state, err
        return Parsec(parse)
